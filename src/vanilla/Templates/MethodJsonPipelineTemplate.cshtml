@using System.Linq;
@using AutoRest.TypeScript.Model
@inherits AutoRest.Core.Template<AutoRest.TypeScript.Model.MethodTS>
// Send Request
let httpResponse: msRest.HttpResponse;
httpResponse = await client.sendRequest(httpRequest);
const statusCode: number = httpResponse.statusCode;
let deserializedBody: { [key: string]: any } = await httpResponse.deserializedBody();
if (@(Model.FailureStatusCodePredicate)) {
  let errorMessage: string = deserializedBody.error && deserializedBody.error.message || deserializedBody.message;
  try {
@if (Model.DefaultResponse.Body != null)
{
    var deserializeErrorBody = Model.GetDeserializationString(Model.DefaultResponse.Body, "deserializedBody", "deserializedBody");
    if (!string.IsNullOrWhiteSpace(deserializeErrorBody))
    {
@:    if (deserializedBody != undefined) {
@:      @(deserializeErrorBody)
@:    }
    }
}
  } catch (deserializationError) {
    errorMessage = `Error "${deserializationError.message}" occurred in deserializing the responseBody - "${JSON.stringify(deserializedBody)}" for the default response.`;
  }
  throw new msRest.RestError(errorMessage, {
    code: deserializedBody.error && deserializedBody.error.code || deserializedBody.code,
    statusCode: httpResponse.statusCode,
    request: httpRequest,
    response: httpResponse,
    body: deserializedBody
  });
}
@Model.InitializeResult
@foreach (var responsePair in Model.Responses.Where(r => r.Value.Body != null))
{
    <text>
// Deserialize Response
if (statusCode === @MethodTS.GetStatusCodeReference(responsePair.Key)) {
  @(Model.DeserializeResponse(responsePair.Value.Body, "deserializedBody"))
}
    </text>
}
@if (Model.ReturnType.Body != null && Model.DefaultResponse.Body != null && !Model.Responses.Any())
{
  @(Model.DeserializeResponse(Model.DefaultResponse.Body, "deserializedBody"))
}
httpResponse.deserializedBody = () => Promise.resolve(deserializedBody);
@EmptyLine
return httpResponse;